<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ‰‹åŠ¿æ§åˆ¶ç²’å­</title>
    <!-- å¼•å…¥ MediaPipe Hands å’Œ Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: 'Arial', sans-serif;
      }

      #canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        display: block;
      }

      /* ç”¨äºMediaPipeå¤„ç†çš„éšè—è§†é¢‘å…ƒç´  */
      .input_video {
        display: none;
      }

      /* çŠ¶æ€åŠ è½½æç¤º */
      #status-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ff88;
        font-size: 24px;
        text-align: center;
        pointer-events: none;
        z-index: 10;
        transition: opacity 0.5s;
      }

      /* å·¦ä¸Šè§’è°ƒè¯•/æç¤ºä¿¡æ¯ */
      #info-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        color: rgba(255, 255, 255, 0.7);
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 8px;
        pointer-events: none;
        user-select: none;
        z-index: 100;
      }

      /* ä¸Šä¼ æŒ‰é’®æ ·å¼ */
      #upload-container {
        position: absolute;
        top: 20px;
        left: 200px; /* æ”¾åœ¨ info-panel å³è¾¹ */
        z-index: 100;
      }

      #file-input {
        display: none;
      }

      .upload-btn {
        background: rgba(0, 255, 136, 0.2);
        border: 1px solid #00ff88;
        color: #00ff88;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
        backdrop-filter: blur(5px);
      }

      .upload-btn:hover {
        background: rgba(0, 255, 136, 0.4);
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
      }

      /* å³ä¸‹è§’æ‰‹åŠ¿æ£€æµ‹æ¿å— */
      #gesture-feedback {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        backdrop-filter: blur(5px);
        z-index: 20;
      }

      #gesture-canvas {
        width: 160px; /* ç¼©ç•¥å›¾å¤§å° */
        height: 120px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.5);
        transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œç¬¦åˆç”¨æˆ·ç…§é•œå­çš„ä¹ æƒ¯ */
      }

      #gesture-status {
        color: white;
        font-size: 14px;
        font-weight: bold;
        text-align: center;
        min-width: 120px;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="particle-canvas"></canvas>
      <div id="status-message">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ¨¡å‹ï¼Œè¯·ç¨å€™...<br />è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
      <div id="info-panel">
        <div>å½“å‰çŠ¶æ€: <span id="current-state" style="color: yellow">ç­‰å¾…æ‰‹åŠ¿...</span></div>
        <div style="font-size: 0.8em; margin-top: 5px">å¼ å¼€æ‰‹æŒ -> æ‰“æ•£ç²’å­</div>
        <div style="font-size: 0.8em">æ¡ç´§æ‹³å¤´ -> èšåˆ</div>
      </div>

      <!-- ä¸Šä¼ å›¾ç‰‡æŒ‰é’® -->
      <div id="upload-container">
        <label for="file-input" class="upload-btn">ğŸ“ ä¸Šä¼ å›¾ç‰‡ç”Ÿæˆç²’å­</label>
        <input type="file" id="file-input" accept="image/*" />
      </div>

      <!-- å³ä¸‹è§’æ‰‹åŠ¿æ£€æµ‹åé¦ˆ -->
      <div id="gesture-feedback">
        <canvas id="gesture-canvas" width="320" height="240"></canvas>
        <div id="gesture-status">ç­‰å¾…æ‘„åƒå¤´...</div>
      </div>
    </div>

    <!-- è§†é¢‘æµè¾“å…¥ -->
    <video class="input_video"></video>

    <script>
      /**
       * @fileoverview æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘
       * ä½¿ç”¨ Canvas ç»˜åˆ¶ç²’å­ï¼ŒMediaPipe Hands è¿›è¡Œæ‰‹åŠ¿è¯†åˆ«ã€‚
       */

      // ==========================================
      // é…ç½®å¸¸é‡
      // ==========================================

      const CONFIG = {
        particleCount: 30000, // å†æ¬¡ç¿»å€ç²’å­æ•°é‡ï¼Œè¿½æ±‚æè‡´æ¸…æ™°åº¦
        colors: [
          '#081c15',
          '#1b4332',
          '#2d6a4f',
          '#40916c',
          '#52b788',
          '#74c69d',
          '#95d5b2', // æ¸å˜ç»¿
          '#d90429',
          '#ef233c', // çº¢è‰²è£…é¥°
          '#ffd60a',
          '#ffcc00', // é‡‘è‰²
          '#caf0f8', // é›ªç™½
        ],
        friction: 0.95,
        ease: 0.05,
        scatterForce: 40,
        treeWidthRatio: 0.5,
        treeHeightRatio: 0.85,
        focalLength: 800,
        rotationSpeed: 0.003, // æ ‘çš„è‡ªè½¬é€Ÿåº¦
        snowCount: 200, // èƒŒæ™¯é›ªèŠ±æ•°é‡
      }

      // ==========================================
      // ç±»å‹å®šä¹‰ (JSDoc)
      // ==========================================

      /**
       * ç²’å­ç±»
       */
      class Particle {
        /**
         * @param {number} canvasWidth ç”»å¸ƒå®½åº¦
         * @param {number} canvasHeight ç”»å¸ƒé«˜åº¦
         */
        constructor(canvasWidth, canvasHeight) {
          // å½“å‰ä½ç½® (3D)
          this.x = (Math.random() - 0.5) * canvasWidth
          this.y = (Math.random() - 0.5) * canvasHeight
          this.z = (Math.random() - 0.5) * 500

          // ç›®æ ‡ä½ç½® (æ ‘å½¢æ€, 3D)
          this.targetX = 0
          this.targetY = 0
          this.targetZ = 0

          // é€Ÿåº¦ (3D)
          this.vx = 0
          this.vy = 0
          this.vz = 0

          // å±æ€§
          this.baseSize = Math.random() * 1.5 + 0.3
          this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]
          this.originalColor = this.color // è®°ä½åˆå§‹é¢œè‰²ï¼ˆæ ‘çš„é¢œè‰²ï¼‰
          this.blinkOffset = Math.random() * 100
          this.blinkSpeed = Math.random() * 0.05 + 0.01
          this.isDecoration = Math.random() < 0.15
        }

        // ... (update æ–¹æ³•ä¿æŒä¸å˜ï¼Œæˆ‘ä»¬ä¸»è¦ä¿®æ”¹ draw æ¥å®ç°è§†è§‰ç‰¹æ•ˆ) ...

        /**
         * æ›´æ–°ç²’å­ç‰©ç†çŠ¶æ€
         * @param {boolean} isAssembling æ˜¯å¦æ­£åœ¨èšåˆ
         * @param {number} width ç”»å¸ƒå®½
         * @param {number} height ç”»å¸ƒé«˜
         */
        update(isAssembling, width, height) {
          if (isAssembling) {
            // èšåˆæ¨¡å¼ï¼šé£å‘ç›®æ ‡ç‚¹ (å¼¹ç°§ç‰©ç†)
            // æ·»åŠ å¾®å°çš„æ­£å¼¦æ³¢åŠ¨ï¼Œæ¨¡æ‹Ÿæ ‘åœ¨å‘¼å¸/é£å¹
            const time = Date.now() * 0.001
            const floatX = Math.sin(time + this.y * 0.01) * 2

            const dx = this.targetX + floatX - this.x
            const dy = this.targetY - this.y
            const dz = this.targetZ - this.z

            this.vx += dx * CONFIG.ease * 0.5
            this.vy += dy * CONFIG.ease * 0.5
            this.vz += dz * CONFIG.ease * 0.5
          } else {
            // æ‰“æ•£æ¨¡å¼
            this.vx *= 0.99 // ç©ºæ°”é˜»åŠ›
            this.vy *= 0.99
            this.vz *= 0.99

            // ç¨å¾®åŠ ç‚¹æ‰°åŠ¨
            this.vx += (Math.random() - 0.5) * 0.2
            this.vy += (Math.random() - 0.5) * 0.2
            this.vz += (Math.random() - 0.5) * 0.2

            // è¾¹ç•Œæ£€æŸ¥ (è½¯è¾¹ç•Œï¼Œå¼¹å›)
            const range = width * 1.5
            if (Math.abs(this.x) > range) this.vx *= -1
            if (Math.abs(this.y) > range) this.vy *= -1
            if (Math.abs(this.z) > 1000) this.vz *= -1
          }

          // åº”ç”¨æ‘©æ“¦åŠ›
          this.vx *= CONFIG.friction
          this.vy *= CONFIG.friction
          this.vz *= CONFIG.friction

          // æ›´æ–°ä½ç½®
          this.x += this.vx
          this.y += this.vy
          this.z += this.vz
        }

        /**
         * ç»˜åˆ¶ç²’å­
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} centerX å±å¹•ä¸­å¿ƒX
         * @param {number} centerY å±å¹•ä¸­å¿ƒY
         * @param {number} rotationY æ•´ä½“æ—‹è½¬è§’åº¦
         */
        draw(ctx, centerX, centerY, rotationY) {
          // 1. æ—‹è½¬è®¡ç®— (ç»• Y è½´)
          const cos = Math.cos(rotationY)
          const sin = Math.sin(rotationY)

          const rx = this.x * cos - this.z * sin
          const rz = this.x * sin + this.z * cos

          // 2. 3D é€è§†æŠ•å½±
          const perspective = CONFIG.focalLength / (CONFIG.focalLength + rz + 400)

          if (perspective < 0) return // åœ¨ç›¸æœºåé¢

          const px = rx * perspective + centerX
          const py = this.y * perspective + centerY
          let size = this.baseSize * perspective

          // 3. è§†è§‰ç‰¹æ•ˆè®¡ç®—
          let alpha = 1

          if (this.isDecoration) {
            // è£…é¥°ç¯ï¼šå‘¼å¸é—ªçƒ
            const blink = Math.sin(Date.now() * this.blinkSpeed + this.blinkOffset)
            alpha = 0.8 + 0.2 * blink
            size *= 1.5 + 0.5 * blink

            // ä¼˜åŒ–ï¼šç§»é™¤æ€§èƒ½æ˜‚è´µçš„ shadowBlurï¼Œæ”¹ç”¨ lighter æ··åˆæ¨¡å¼ä¸‹çš„é¢œè‰²å åŠ 
            // åªæœ‰è£…é¥°ç¯æ‰ä½¿ç”¨é«˜äº®è‰²
          } else {
            // æ™®é€šæ ‘å¶ï¼šæµå…‰æ•ˆæœ (ä»ä¸‹å¾€ä¸Šæ‰«æçš„å…‰æ³¢)
            // æ³¨æ„ï¼šä»…å½“ä¸æ˜¯å›¾ç‰‡æ¨¡å¼æ—¶æ‰å¯ç”¨æµå…‰ï¼Œå¦åˆ™ä¼šå¹²æ‰°å›¾ç‰‡é¢œè‰²
            // ç®€å•åˆ¤æ–­ï¼šå¦‚æœé¢œè‰²æ˜¯ rgb() æ ¼å¼ï¼ˆå›¾ç‰‡æ¨¡å¼ï¼‰ï¼Œå°±ä¸åŠ æµå…‰
            if (!this.color.startsWith('rgb')) {
              const time = Date.now() * 0.002
              const wave = Math.sin(this.y * 0.01 - time)
              // å¦‚æœå¤„äºå…‰æ³¢ä¸­ï¼Œå˜äº®
              if (wave > 0.8) {
                ctx.fillStyle = '#b7e4c7' // é«˜äº®ç»¿
                alpha = 1
              } else {
                ctx.fillStyle = this.color
                alpha = 0.8
              }
            } else {
              // å›¾ç‰‡æ¨¡å¼ï¼šç›´æ¥ç”¨åŸè‰²
              ctx.fillStyle = this.color
              // å›¾ç‰‡æ¨¡å¼ä¸‹ï¼Œalpha è®¾ä¸º 1ï¼Œä¿æŒé¢œè‰²é²œè‰³
              alpha = 1
            }
          }

          ctx.globalAlpha = alpha

          if (this.isDecoration) {
            ctx.fillStyle = this.color
            // æ¨¡æ‹Ÿå‘å…‰ï¼šå…ˆç”»ä¸€ä¸ªå¤§ä¸€ç‚¹çš„åŠé€æ˜å…‰æ™•ï¼ˆä»…å¯¹è¾ƒå¤§çš„è£…é¥°ç¯ï¼‰
            if (size > 2) {
              ctx.globalAlpha = 0.3
              ctx.beginPath()
              ctx.arc(px, py, size * 2, 0, Math.PI * 2)
              ctx.fill()
              ctx.globalAlpha = alpha // æ¢å¤é€æ˜åº¦
            }
          } else {
            // å†æ¬¡ç¡®ä¿éè£…é¥°ç¯ï¼ˆå°¤å…¶æ˜¯å›¾ç‰‡ç²’å­ï¼‰è¢«å¡«å……é¢œè‰²
            if (this.color.startsWith('rgb')) {
              ctx.fillStyle = this.color
            }
          }

          ctx.beginPath()
          // å›¾ç‰‡æ¨¡å¼ä¸‹ï¼Œä¸ºäº†è®©åƒç´ æ›´é¥±æ»¡ï¼Œå¯ä»¥ç”»æ–¹å½¢æˆ–è€…ç¨å¾®å¤§ä¸€ç‚¹çš„åœ†
          // è¿™é‡Œæˆ‘ä»¬ä¿æŒåœ†å½¢ï¼Œä½†ç¡®ä¿æ²¡æœ‰å…‰æ™•å¹²æ‰°
          ctx.arc(px, py, size, 0, Math.PI * 2)
          ctx.fill()
        }

        // ... setTarget, explode ä¿æŒä¸å˜ ...
        /**
         * è®¾ç½®æ–°çš„ç›®æ ‡ä½ç½®
         */
        setTarget(tx, ty, tz) {
          this.targetX = tx
          this.targetY = ty
          this.targetZ = tz
        }

        /**
         * æ–½åŠ çˆ†ç‚¸åŠ›
         */
        explode(centerX, centerY) {
          const dist = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) + 0.1
          const force = Math.random() * CONFIG.scatterForce + 20

          this.vx = (this.x / dist) * force
          this.vy = (this.y / dist) * force
          this.vz = (this.z / dist) * force
        }
      }

      /**
       * èƒŒæ™¯é›ªèŠ±ç±»
       */
      class Snow {
        constructor(width, height) {
          this.init(width, height)
        }

        init(width, height) {
          this.x = Math.random() * width
          this.y = Math.random() * height
          this.z = Math.random() * 500 // æ·±åº¦
          this.size = Math.random() * 2 + 1
          this.speedY = Math.random() * 1 + 0.5
          this.opacity = Math.random() * 0.5 + 0.2
        }

        update(width, height) {
          this.y += this.speedY
          if (this.y > height) {
            this.y = -10
            this.x = Math.random() * width
          }
        }

        draw(ctx) {
          ctx.fillStyle = 'rgba(255, 255, 255, ' + this.opacity + ')'
          ctx.beginPath()
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2)
          ctx.fill()
        }
      }

      // ==========================================
      // ä¸»é€»è¾‘
      // ==========================================

      const canvas = document.getElementById('particle-canvas')
      const ctx = canvas.getContext('2d')
      const statusEl = document.getElementById('status-message')
      const stateTextEl = document.getElementById('current-state')
      const videoElement = document.getElementsByClassName('input_video')[0]

      // å³ä¸‹è§’é¢„è§ˆç›¸å…³
      const gestureCanvas = document.getElementById('gesture-canvas')
      const gestureCtx = gestureCanvas.getContext('2d')
      const gestureStatusEl = document.getElementById('gesture-status')

      // ä¸Šä¼ ç›¸å…³
      const fileInput = document.getElementById('file-input')
      let isImageMode = false // å½“å‰æ˜¯å¦ä¸ºå›¾ç‰‡æ¨¡å¼

      let width, height
      let particles = []
      let snowParticles = []
      let isAssembling = true // true = æ ‘, false = æ•£å¼€
      let handModelLoaded = false
      let animationFrameId
      let treeRotation = 0 // æ ‘çš„å½“å‰æ—‹è½¬è§’åº¦

      /**
       * åˆå§‹åŒ– Canvas å°ºå¯¸
       */
      function resize() {
        width = window.innerWidth
        height = window.innerHeight
        canvas.width = width
        canvas.height = height

        if (isImageMode) {
          // å¦‚æœå½“å‰æ˜¯å›¾ç‰‡æ¨¡å¼ï¼Œé‡æ–°å¤„ç†å›¾ç‰‡ï¼ˆä¸ºäº†é€‚é…æ–°å±å¹•å°ºå¯¸ï¼‰
          // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šç›´æ¥åˆ‡å›é»˜è®¤æ¨¡å¼
          isImageMode = false
          calculateDefaultShape()
        } else {
          calculateDefaultShape()
        }

        initSnow()
      }

      /**
       * å¤„ç†ä¸Šä¼ å›¾ç‰‡
       */
      fileInput.addEventListener('change', function (e) {
        const file = e.target.files[0]
        if (!file) return

        const reader = new FileReader()
        reader.onload = function (event) {
          const img = new Image()
          img.onload = function () {
            processImageToParticles(img)
          }
          img.src = event.target.result
        }
        reader.readAsDataURL(file)
      })

      /**
       * å°†å›¾ç‰‡è½¬æ¢ä¸ºç²’å­ç›®æ ‡ç‚¹
       */
      function processImageToParticles(img) {
        isImageMode = true

        // 1. åˆ›å»ºç¦»å± Canvas è·å–åƒç´ æ•°æ®
        const offCanvas = document.createElement('canvas')
        const offCtx = offCanvas.getContext('2d')

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œè®©å›¾ç‰‡é€‚åº”å±å¹•ï¼Œä½†ä¸è¦å¤ªå¤§
        // ç›®æ ‡æ˜¯è®©å›¾ç‰‡å æ®å±å¹•çº¦ 60% - 80% çš„åŒºåŸŸ
        const screenRatio = width / height
        const imgRatio = img.width / img.height

        let drawW, drawH
        if (imgRatio > screenRatio) {
          drawW = Math.floor(width * 0.6)
          drawH = Math.floor(drawW / imgRatio)
        } else {
          drawH = Math.floor(height * 0.6)
          drawW = Math.floor(drawH * imgRatio)
        }

        offCanvas.width = drawW
        offCanvas.height = drawH

        // ç»˜åˆ¶å›¾ç‰‡
        offCtx.drawImage(img, 0, 0, drawW, drawH)
        const imgData = offCtx.getImageData(0, 0, drawW, drawH)
        const data = imgData.data
        const dataWidth = imgData.width // å¿…é¡»ä½¿ç”¨çœŸå®çš„æ•´æ•°å®½åº¦ä½œä¸º stride

        // 2. é‡‡æ ·åƒç´ ç‚¹
        const totalPixels = drawW * drawH
        // æˆ‘ä»¬å¸Œæœ›é‡‡æ ·å‡ºå¤§çº¦ CONFIG.particleCount ä¸ªç‚¹
        // step æ˜¯æ­¥é•¿
        const step = Math.ceil(Math.sqrt(totalPixels / CONFIG.particleCount))

        let particleIndex = 0

        // åç§»é‡ï¼Œè®©å›¾ç‰‡å±…ä¸­
        const offsetX = (width - drawW) / 2
        const offsetY = (height - drawH) / 2 - height * 0.05 // ç¨å¾®é ä¸Šä¸€ç‚¹

        for (let y = 0; y < drawH; y += step) {
          for (let x = 0; x < drawW; x += step) {
            // è·å–åƒç´ ç´¢å¼•
            // å…³é”®ä¿®å¤ï¼šä½¿ç”¨æ•´æ•°å®½åº¦ dataWidth è®¡ç®—ç´¢å¼•ï¼Œé˜²æ­¢é”™ä½
            const index = (y * dataWidth + x) * 4

            const r = data[index]
            const g = data[index + 1]
            const b = data[index + 2]
            const a = data[index + 3]

            // å¿½ç•¥é€æ˜åƒç´ å’Œè¿‡æš—çš„åƒç´ ï¼ˆå¯é€‰ï¼‰
            if (a < 128) continue

            if (particleIndex < particles.length) {
              const p = particles[particleIndex]

              // è®¾ç½®ç›®æ ‡ä½ç½® (å›¾ç‰‡æ˜¯ 2D çš„ï¼ŒZ è®¾ä¸º 0)
              const targetX = x - drawW / 2
              const targetY = y - drawH / 2
              const targetZ = 0

              p.setTarget(targetX, targetY, targetZ)

              // è®¾ç½®é¢œè‰²
              p.color = `rgb(${r},${g},${b})`
              p.isDecoration = false

              // å…³é”®ä¿®å¤ï¼šæ ¹æ®æ­¥é•¿åŠ¨æ€è°ƒæ•´ç²’å­å¤§å°ï¼Œä½¿å…¶èƒ½å¡«æ»¡ç”»é¢
              // step æ˜¯é‡‡æ ·æ­¥é•¿
              // ç²’å­æ•°é‡ç¿»å€åï¼Œstep ä¼šå˜å¾—éå¸¸å°
              // è®¾ç½®ä¸º 1.05 ä¿è¯ç´§å¯†æ’åˆ—ä¸”å‡ ä¹æ— é‡å ï¼Œè·å¾—æœ€é”åˆ©çš„åƒç´ æ„Ÿ
              p.baseSize = step * 1.05

              particleIndex++
            }
          }
        }

        // 3. å¤„ç†å¤šä½™çš„ç²’å­
        // å¦‚æœå›¾ç‰‡é‡‡æ ·ç‚¹å°‘äºç²’å­æ€»æ•°ï¼Œå‰©ä¸‹çš„ç²’å­è®©å®ƒä»¬éšè—æˆ–é£åˆ°æ— ç©·è¿œï¼Œæˆ–è€…ç»„æˆä¸€ä¸ªè¾¹æ¡†
        // è¿™é‡Œæˆ‘ä»¬è®©å®ƒä»¬éšæœºåˆ†å¸ƒåœ¨èƒŒæ™¯é‡Œï¼Œå˜æš—
        for (let i = particleIndex; i < particles.length; i++) {
          const p = particles[i]
          // è®©å¤šä½™ç²’å­å˜æˆèƒŒæ™¯æ˜Ÿç©º
          p.setTarget((Math.random() - 0.5) * width * 2, (Math.random() - 0.5) * height * 2, (Math.random() - 0.5) * 1000)
          p.color = 'rgba(255,255,255,0.1)'
          p.isDecoration = false
        }

        // æç¤º
        stateTextEl.innerText = 'å›¾ç‰‡å·²åŠ è½½ (æ¡æ‹³æŸ¥çœ‹)'
      }

      /**
       * è®¡ç®—é»˜è®¤å½¢çŠ¶ (çƒä½“)
       * å–ä»£åŸæ¥çš„åœ£è¯æ ‘
       */
      function calculateDefaultShape() {
        const radius = Math.min(width, height) * 0.35

        particles.forEach((p) => {
          // çƒé¢éšæœºåˆ†å¸ƒ (Marsaglia method æˆ– ç®€å•çš„æåæ ‡)
          // ä¸ºäº†å‡åŒ€åˆ†å¸ƒï¼Œä½¿ç”¨ phi = acos(2v-1)
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(Math.random() * 2 - 1)

          const x = radius * Math.sin(phi) * Math.cos(theta)
          const y = radius * Math.sin(phi) * Math.sin(theta)
          const z = radius * Math.cos(phi)

          p.setTarget(x, y, z)

          // éšæœºé¢œè‰²
          p.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]
          p.originalColor = p.color

          // å°‘é‡è£…é¥°ç‚¹
          if (Math.random() < 0.1) {
            p.isDecoration = true
            p.baseSize = Math.random() * 2 + 1.5
          } else {
            p.isDecoration = false
            p.baseSize = Math.random() * 1.5 + 0.3
          }
        })
      }

      /**
       * åˆå§‹åŒ–èƒŒæ™¯é›ªèŠ±
       */
      function initSnow() {
        snowParticles = []
        for (let i = 0; i < CONFIG.snowCount; i++) {
          snowParticles.push(new Snow(width, height))
        }
      }

      /**
       * åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
       */
      function initParticles() {
        particles = []
        for (let i = 0; i < CONFIG.particleCount; i++) {
          particles.push(new Particle(width, height))
        }
        calculateDefaultShape()
        initSnow()
      }

      /**
       * æ¸²æŸ“å¾ªç¯
       */
      function loop() {
        // æ‹–å°¾æ•ˆæœ
        ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'
        ctx.fillRect(0, 0, width, height)

        // ç»˜åˆ¶èƒŒæ™¯é›ªèŠ± (ä¸å‘å…‰ï¼Œæ­£å¸¸æ··åˆ)
        ctx.globalCompositeOperation = 'source-over'
        snowParticles.forEach((p) => {
          p.update(width, height)
          p.draw(ctx)
        })

        // æ··åˆæ¨¡å¼æ§åˆ¶ï¼š
        // é»˜è®¤æ¨¡å¼ï¼ˆçƒä½“ï¼‰ï¼šä½¿ç”¨ 'lighter' è®©ç²’å­é‡å å‘å…‰
        // å›¾ç‰‡æ¨¡å¼ï¼šä½¿ç”¨ 'source-over' æ­£å¸¸è¦†ç›–ï¼Œç¡®ä¿é¢œè‰²è¿˜åŸå‡†ç¡®
        if (isImageMode) {
          ctx.globalCompositeOperation = 'source-over'
        } else {
          ctx.globalCompositeOperation = 'lighter'
        }

        const centerX = width / 2
        const centerY = height / 2

        // æ›´æ–°æ—‹è½¬è§’åº¦
        if (isAssembling && !isImageMode) {
          treeRotation += CONFIG.rotationSpeed
        } else if (isImageMode) {
          // å›¾ç‰‡æ¨¡å¼ä¸‹ï¼Œä¸ºäº†çœ‹æ¸…å›¾ç‰‡ï¼Œè®©æ—‹è½¬å½’é›¶æˆ–è€…ç¼“æ…¢å¤ä½
          treeRotation = treeRotation * 0.95
        }

        particles.forEach((p) => {
          p.update(isAssembling, width, height)
          p.draw(ctx, centerX, centerY, treeRotation)
        })

        ctx.globalCompositeOperation = 'source-over'

        animationFrameId = requestAnimationFrame(loop)
      }

      /**
       * åˆ‡æ¢çŠ¶æ€é€»è¾‘
       * @param {boolean} shouldAssemble
       */
      function toggleState(shouldAssemble) {
        if (isAssembling === shouldAssemble) return // çŠ¶æ€æœªæ”¹å˜

        isAssembling = shouldAssemble

        if (isAssembling) {
          stateTextEl.innerText = 'èšåˆ'
          stateTextEl.style.color = '#00ff88'
        } else {
          stateTextEl.innerText = 'æ‰“æ•£'
          stateTextEl.style.color = '#ff4444'
          // è§¦å‘çˆ†ç‚¸æ•ˆæœ (ç›¸å¯¹äºæ ‘ä¸­å¿ƒ 0,0,0)
          particles.forEach((p) => p.explode(0, 0))
        }
      }

      // ==========================================
      // MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
      // ==========================================

      /**
       * å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
       * @param {object} results
       */
      function onResults(results) {
        if (!handModelLoaded) {
          handModelLoaded = true
          statusEl.style.opacity = 0 // éšè—åŠ è½½æç¤º
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          // å–ç¬¬ä¸€åªæ£€æµ‹åˆ°çš„æ‰‹
          const landmarks = results.multiHandLandmarks[0]

          // ç®€å•çš„å¼ æ‰‹/æ¡æ‹³æ£€æµ‹ç®—æ³•
          // è®¡ç®—æŒ‡å°– (8, 12, 16, 20) åˆ° æŒå¿ƒ (0 æˆ– 9) çš„å¹³å‡è·ç¦»
          // è¿™é‡Œä½¿ç”¨ 0 (WRIST) ä½œä¸ºå‚è€ƒç‚¹æ›´ç¨³å®š

          const wrist = landmarks[0]
          const tips = [8, 12, 16, 20] // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡å°–

          let avgDistance = 0

          tips.forEach((idx) => {
            const tip = landmarks[idx]
            // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦» (ä»…ä½¿ç”¨ x, y)
            const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2))
            avgDistance += dist
          })

          avgDistance /= tips.length

          // é˜ˆå€¼åˆ¤æ–­ (æ ¹æ®ç»éªŒå€¼è°ƒè¯•ï¼ŒWebcamåæ ‡æ˜¯å½’ä¸€åŒ–çš„ 0.0~1.0)
          // é€šå¸¸æ¡æ‹³æ—¶è·ç¦»å¾ˆå° (< 0.25)ï¼Œå¼ æ‰‹æ—¶è·ç¦»è¾ƒå¤§ (> 0.4)

          // è°ƒè¯•æ—¥å¿— (å¯é€‰æ‰“å¼€)
          // console.log("Avg Dist:", avgDistance);

          let statusText = 'æœªçŸ¥çŠ¶æ€'
          let statusColor = 'white'

          if (avgDistance < 0.25) {
            // è®¤ä¸ºæ˜¯æ¡æ‹³ -> æ ‘
            toggleState(true)
            statusText = 'âœŠ æ¡æ‹³ (èšåˆ)'
            statusColor = '#00ff88'
          } else if (avgDistance > 0.35) {
            // è®¤ä¸ºæ˜¯å¼ æ‰‹ -> æ‰“æ•£
            toggleState(false)
            statusText = 'ğŸ– å¼ å¼€ (æ‰“æ•£)'
            statusColor = '#ff4444'
          } else {
            statusText = 'âœ‹ è°ƒæ•´ä¸­...'
            statusColor = '#ffff00'
          }

          // æ›´æ–°å³ä¸‹è§’çŠ¶æ€æ–‡å­—
          gestureStatusEl.innerText = statusText
          gestureStatusEl.style.color = statusColor

          // æ›´æ–°å³ä¸‹è§’é¢„è§ˆç”»é¢
          // 1. ç»˜åˆ¶è§†é¢‘å¸§
          gestureCtx.save()
          gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height)
          gestureCtx.drawImage(results.image, 0, 0, gestureCanvas.width, gestureCanvas.height)

          // 2. ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
          if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
              drawConnectors(gestureCtx, landmarks, HAND_CONNECTIONS, {
                color: '#00FF00',
                lineWidth: 5,
              })
              drawLandmarks(gestureCtx, landmarks, {
                color: '#FF0000',
                lineWidth: 2,
              })
            }
          }
          gestureCtx.restore()
        } else {
          // æœªæ£€æµ‹åˆ°æ‰‹
          gestureStatusEl.innerText = 'æœªæ£€æµ‹åˆ°æ‰‹'
          gestureStatusEl.style.color = '#aaaaaa'

          // ä»ç„¶æ˜¾ç¤ºè§†é¢‘æµ
          gestureCtx.drawImage(results.image, 0, 0, gestureCanvas.width, gestureCanvas.height)
        }
      }

      /**
       * åˆå§‹åŒ– MediaPipe Hands
       */
      async function initHands() {
        try {
          const hands = new Hands({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            },
          })

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7,
          })

          hands.onResults(onResults)

          const camera = new Camera(videoElement, {
            onFrame: async () => {
              await hands.send({ image: videoElement })
            },
            width: 640,
            height: 480,
          })

          await camera.start()
        } catch (error) {
          console.error('æ‘„åƒå¤´æˆ–æ¨¡å‹åˆå§‹åŒ–å¤±è´¥:', error)
          statusEl.innerText = 'åˆå§‹åŒ–å¤±è´¥: è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™æˆ–ç½‘ç»œè¿æ¥'
          statusEl.style.color = 'red'
        }
      }

      // ==========================================
      // å¯åŠ¨å…¥å£
      // ==========================================

      window.addEventListener('resize', resize)

      // å¯åŠ¨
      resize()
      initParticles()
      loop()
      initHands() // å¯åŠ¨æ‘„åƒå¤´å’ŒAI
    </script>
  </body>
</html>
