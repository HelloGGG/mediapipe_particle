<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘</title>
    <!-- å¼•å…¥ MediaPipe Hands å’Œ Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: 'Arial', sans-serif;
      }

      #canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        display: block;
      }

      /* ç”¨äºMediaPipeå¤„ç†çš„éšè—è§†é¢‘å…ƒç´  */
      .input_video {
        display: none;
      }

      /* çŠ¶æ€åŠ è½½æç¤º */
      #status-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ff88;
        font-size: 24px;
        text-align: center;
        pointer-events: none;
        z-index: 10;
        transition: opacity 0.5s;
      }

      /* å·¦ä¸Šè§’è°ƒè¯•/æç¤ºä¿¡æ¯ */
      #info-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        color: rgba(255, 255, 255, 0.7);
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 8px;
        pointer-events: none;
        user-select: none;
      }

      /* å³ä¸‹è§’æ‰‹åŠ¿æ£€æµ‹æ¿å— */
      #gesture-feedback {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        backdrop-filter: blur(5px);
        z-index: 20;
      }

      #gesture-canvas {
        width: 160px; /* ç¼©ç•¥å›¾å¤§å° */
        height: 120px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.5);
        transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œç¬¦åˆç”¨æˆ·ç…§é•œå­çš„ä¹ æƒ¯ */
      }

      #gesture-status {
        color: white;
        font-size: 14px;
        font-weight: bold;
        text-align: center;
        min-width: 120px;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="particle-canvas"></canvas>
      <div id="status-message">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ¨¡å‹ï¼Œè¯·ç¨å€™...<br />è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
      <div id="info-panel">
        <div>å½“å‰çŠ¶æ€: <span id="current-state" style="color: yellow">ç­‰å¾…æ‰‹åŠ¿...</span></div>
        <div style="font-size: 0.8em; margin-top: 5px">å¼ å¼€æ‰‹æŒ -> æ‰“æ•£ç²’å­</div>
        <div style="font-size: 0.8em">æ¡ç´§æ‹³å¤´ -> èšåˆæˆæ ‘</div>
      </div>

      <!-- å³ä¸‹è§’æ‰‹åŠ¿æ£€æµ‹åé¦ˆ -->
      <div id="gesture-feedback">
        <canvas id="gesture-canvas" width="320" height="240"></canvas>
        <div id="gesture-status">ç­‰å¾…æ‘„åƒå¤´...</div>
      </div>
    </div>

    <!-- è§†é¢‘æµè¾“å…¥ -->
    <video class="input_video"></video>

    <script>
      /**
       * @fileoverview æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘
       * ä½¿ç”¨ Canvas ç»˜åˆ¶ç²’å­ï¼ŒMediaPipe Hands è¿›è¡Œæ‰‹åŠ¿è¯†åˆ«ã€‚
       */

      // ==========================================
      // é…ç½®å¸¸é‡
      // ==========================================

      const CONFIG = {
        particleCount: 3000, // é™ä½ç²’å­æ•°é‡ä»¥ä¼˜åŒ–æ€§èƒ½
        colors: [
          '#081c15',
          '#1b4332',
          '#2d6a4f',
          '#40916c',
          '#52b788',
          '#74c69d',
          '#95d5b2', // æ¸å˜ç»¿
          '#d90429',
          '#ef233c', // çº¢è‰²è£…é¥°
          '#ffd60a',
          '#ffcc00', // é‡‘è‰²
          '#caf0f8', // é›ªç™½
        ],
        friction: 0.95,
        ease: 0.05,
        scatterForce: 40,
        treeWidthRatio: 0.5,
        treeHeightRatio: 0.85,
        focalLength: 800,
        rotationSpeed: 0.003, // æ ‘çš„è‡ªè½¬é€Ÿåº¦
        snowCount: 200, // èƒŒæ™¯é›ªèŠ±æ•°é‡
      }

      // ==========================================
      // ç±»å‹å®šä¹‰ (JSDoc)
      // ==========================================

      /**
       * ç²’å­ç±»
       */
      class Particle {
        /**
         * @param {number} canvasWidth ç”»å¸ƒå®½åº¦
         * @param {number} canvasHeight ç”»å¸ƒé«˜åº¦
         */
        constructor(canvasWidth, canvasHeight) {
          // å½“å‰ä½ç½® (3D)
          this.x = (Math.random() - 0.5) * canvasWidth
          this.y = (Math.random() - 0.5) * canvasHeight
          this.z = (Math.random() - 0.5) * 500

          // ç›®æ ‡ä½ç½® (æ ‘å½¢æ€, 3D)
          this.targetX = 0
          this.targetY = 0
          this.targetZ = 0

          // é€Ÿåº¦ (3D)
          this.vx = 0
          this.vy = 0
          this.vz = 0

          // å±æ€§
          this.baseSize = Math.random() * 1.5 + 0.3
          this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]
          this.blinkOffset = Math.random() * 100
          this.blinkSpeed = Math.random() * 0.05 + 0.01
          this.isDecoration = Math.random() < 0.15
        }

        // ... (update æ–¹æ³•ä¿æŒä¸å˜ï¼Œæˆ‘ä»¬ä¸»è¦ä¿®æ”¹ draw æ¥å®ç°è§†è§‰ç‰¹æ•ˆ) ...

        /**
         * æ›´æ–°ç²’å­ç‰©ç†çŠ¶æ€
         * @param {boolean} isAssembling æ˜¯å¦æ­£åœ¨èšåˆ
         * @param {number} width ç”»å¸ƒå®½
         * @param {number} height ç”»å¸ƒé«˜
         */
        update(isAssembling, width, height) {
          if (isAssembling) {
            // èšåˆæ¨¡å¼ï¼šé£å‘ç›®æ ‡ç‚¹ (å¼¹ç°§ç‰©ç†)
            // æ·»åŠ å¾®å°çš„æ­£å¼¦æ³¢åŠ¨ï¼Œæ¨¡æ‹Ÿæ ‘åœ¨å‘¼å¸/é£å¹
            const time = Date.now() * 0.001
            const floatX = Math.sin(time + this.y * 0.01) * 2

            const dx = this.targetX + floatX - this.x
            const dy = this.targetY - this.y
            const dz = this.targetZ - this.z

            this.vx += dx * CONFIG.ease * 0.5
            this.vy += dy * CONFIG.ease * 0.5
            this.vz += dz * CONFIG.ease * 0.5
          } else {
            // æ‰“æ•£æ¨¡å¼
            this.vx *= 0.99 // ç©ºæ°”é˜»åŠ›
            this.vy *= 0.99
            this.vz *= 0.99

            // ç¨å¾®åŠ ç‚¹æ‰°åŠ¨
            this.vx += (Math.random() - 0.5) * 0.2
            this.vy += (Math.random() - 0.5) * 0.2
            this.vz += (Math.random() - 0.5) * 0.2

            // è¾¹ç•Œæ£€æŸ¥ (è½¯è¾¹ç•Œï¼Œå¼¹å›)
            const range = width * 1.5
            if (Math.abs(this.x) > range) this.vx *= -1
            if (Math.abs(this.y) > range) this.vy *= -1
            if (Math.abs(this.z) > 1000) this.vz *= -1
          }

          // åº”ç”¨æ‘©æ“¦åŠ›
          this.vx *= CONFIG.friction
          this.vy *= CONFIG.friction
          this.vz *= CONFIG.friction

          // æ›´æ–°ä½ç½®
          this.x += this.vx
          this.y += this.vy
          this.z += this.vz
        }

        /**
         * ç»˜åˆ¶ç²’å­
         * @param {CanvasRenderingContext2D} ctx
         * @param {number} centerX å±å¹•ä¸­å¿ƒX
         * @param {number} centerY å±å¹•ä¸­å¿ƒY
         * @param {number} rotationY æ•´ä½“æ—‹è½¬è§’åº¦
         */
        draw(ctx, centerX, centerY, rotationY) {
          // 1. æ—‹è½¬è®¡ç®— (ç»• Y è½´)
          const cos = Math.cos(rotationY)
          const sin = Math.sin(rotationY)

          const rx = this.x * cos - this.z * sin
          const rz = this.x * sin + this.z * cos

          // 2. 3D é€è§†æŠ•å½±
          const perspective = CONFIG.focalLength / (CONFIG.focalLength + rz + 400)

          if (perspective < 0) return // åœ¨ç›¸æœºåé¢

          const px = rx * perspective + centerX
          const py = this.y * perspective + centerY
          let size = this.baseSize * perspective

          // 3. è§†è§‰ç‰¹æ•ˆè®¡ç®—
          let alpha = 1

          if (this.isDecoration) {
            // è£…é¥°ç¯ï¼šå‘¼å¸é—ªçƒ
            const blink = Math.sin(Date.now() * this.blinkSpeed + this.blinkOffset)
            alpha = 0.8 + 0.2 * blink
            size *= 1.5 + 0.5 * blink

            // ä¼˜åŒ–ï¼šç§»é™¤æ€§èƒ½æ˜‚è´µçš„ shadowBlurï¼Œæ”¹ç”¨ lighter æ··åˆæ¨¡å¼ä¸‹çš„é¢œè‰²å åŠ 
            // åªæœ‰è£…é¥°ç¯æ‰ä½¿ç”¨é«˜äº®è‰²
          } else {
            // æ™®é€šæ ‘å¶ï¼šæµå…‰æ•ˆæœ (ä»ä¸‹å¾€ä¸Šæ‰«æçš„å…‰æ³¢)
            const time = Date.now() * 0.002
            const wave = Math.sin(this.y * 0.01 - time)
            // å¦‚æœå¤„äºå…‰æ³¢ä¸­ï¼Œå˜äº®
            if (wave > 0.8) {
              ctx.fillStyle = '#b7e4c7' // é«˜äº®ç»¿
              alpha = 1
            } else {
              ctx.fillStyle = this.color
              alpha = 0.8
            }
          }

          ctx.globalAlpha = alpha

          if (this.isDecoration) {
            ctx.fillStyle = this.color
            // æ¨¡æ‹Ÿå‘å…‰ï¼šå…ˆç”»ä¸€ä¸ªå¤§ä¸€ç‚¹çš„åŠé€æ˜å…‰æ™•ï¼ˆä»…å¯¹è¾ƒå¤§çš„è£…é¥°ç¯ï¼‰
            if (size > 2) {
              ctx.globalAlpha = 0.3
              ctx.beginPath()
              ctx.arc(px, py, size * 2, 0, Math.PI * 2)
              ctx.fill()
              ctx.globalAlpha = alpha // æ¢å¤é€æ˜åº¦
            }
          }

          ctx.beginPath()
          ctx.arc(px, py, size, 0, Math.PI * 2)
          ctx.fill()
        }

        // ... setTarget, explode ä¿æŒä¸å˜ ...
        /**
         * è®¾ç½®æ–°çš„ç›®æ ‡ä½ç½®
         */
        setTarget(tx, ty, tz) {
          this.targetX = tx
          this.targetY = ty
          this.targetZ = tz
        }

        /**
         * æ–½åŠ çˆ†ç‚¸åŠ›
         */
        explode(centerX, centerY) {
          const dist = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) + 0.1
          const force = Math.random() * CONFIG.scatterForce + 20

          this.vx = (this.x / dist) * force
          this.vy = (this.y / dist) * force
          this.vz = (this.z / dist) * force
        }
      }

      /**
       * èƒŒæ™¯é›ªèŠ±ç±»
       */
      class Snow {
        constructor(width, height) {
          this.init(width, height)
        }

        init(width, height) {
          this.x = Math.random() * width
          this.y = Math.random() * height
          this.z = Math.random() * 500 // æ·±åº¦
          this.size = Math.random() * 2 + 1
          this.speedY = Math.random() * 1 + 0.5
          this.opacity = Math.random() * 0.5 + 0.2
        }

        update(width, height) {
          this.y += this.speedY
          if (this.y > height) {
            this.y = -10
            this.x = Math.random() * width
          }
        }

        draw(ctx) {
          ctx.fillStyle = 'rgba(255, 255, 255, ' + this.opacity + ')'
          ctx.beginPath()
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2)
          ctx.fill()
        }
      }

      // ==========================================
      // ä¸»é€»è¾‘
      // ==========================================

      const canvas = document.getElementById('particle-canvas')
      const ctx = canvas.getContext('2d')
      const statusEl = document.getElementById('status-message')
      const stateTextEl = document.getElementById('current-state')
      const videoElement = document.getElementsByClassName('input_video')[0]

      // å³ä¸‹è§’é¢„è§ˆç›¸å…³
      const gestureCanvas = document.getElementById('gesture-canvas')
      const gestureCtx = gestureCanvas.getContext('2d')
      const gestureStatusEl = document.getElementById('gesture-status')

      let width, height
      let particles = []
      let snowParticles = []
      let isAssembling = true // true = æ ‘, false = æ•£å¼€
      let handModelLoaded = false
      let animationFrameId
      let treeRotation = 0 // æ ‘çš„å½“å‰æ—‹è½¬è§’åº¦

      /**
       * åˆå§‹åŒ– Canvas å°ºå¯¸
       */
      function resize() {
        width = window.innerWidth
        height = window.innerHeight
        canvas.width = width
        canvas.height = height
        calculateTreeShape()
        initSnow()
      }

      /**
       * è®¡ç®—åœ£è¯æ ‘å½¢çŠ¶ (3D åˆ†å±‚éšæœºåˆ†å¸ƒ)
       */
      function calculateTreeShape() {
        const treeHeight = height * CONFIG.treeHeightRatio
        const maxRadius = Math.min(width * 0.4, 300) // é™åˆ¶æœ€å¤§å®½åº¦
        const treeYOffset = height * 0.15 // å‘ä¸Šåç§» 15% çš„å±å¹•é«˜åº¦

        particles.forEach((p, i) => {
          // 1. æ ‘å¹²é€»è¾‘ (å›ºå®šåˆ†é… 12% çš„ç²’å­ç»™æ ‘å¹²ï¼Œä¿è¯å¯†åº¦)
          if (i < particles.length * 0.12) {
            const trunkR = maxRadius * 0.1 * Math.random() // æ ‘å¹²ç¨ç»†ä¸€ç‚¹
            const angle = Math.random() * Math.PI * 2
            const x = Math.cos(angle) * trunkR
            const z = Math.sin(angle) * trunkR

            // æ ‘å¹² Y è½´èŒƒå›´ï¼šä»æ ‘å† å†…éƒ¨å»¶ä¼¸å‡ºæ¥
            // æ ‘å† åº•éƒ¨çº¦ä¸º treeHeight * 0.5
            // æˆ‘ä»¬è®©æ ‘å¹²ä» treeHeight * 0.35 (æ’å…¥æ ‘å† ) åˆ° treeHeight * 0.75 (å‘ä¸‹å»¶ä¼¸)
            const yMin = treeHeight * 0.35
            const yMax = treeHeight * 0.75
            const y = yMin + Math.random() * (yMax - yMin) - treeYOffset

            p.setTarget(x, y, z)
            p.color = '#5c4033' // æ·±ä¸€ç‚¹çš„æœ¨å¤´è‰²
            p.isDecoration = false
            p.baseSize = Math.random() * 2 + 1 // æ ‘å¹²ç²’å­ç¨å¾®æ‰å®ä¸€ç‚¹
            return
          }

          // 2. æ ‘å† ä¸»ä½“
          // éšæœºé«˜åº¦ t: 0(é¡¶) -> 1(åº•)
          let t = Math.random()
          // ä½¿ç”¨ pow è®©ç²’å­æ›´å€¾å‘äºåˆ†å¸ƒåœ¨åº•éƒ¨
          t = Math.pow(t, 0.8)

          // åœ†é”¥åŠå¾„éšé«˜åº¦å˜åŒ–
          const currentMaxR = t * maxRadius
          // åœ¨æˆªé¢åœ†å†…éšæœºåˆ†å¸ƒ
          const r = currentMaxR * Math.sqrt(Math.random())
          const angle = Math.random() * Math.PI * 2

          let x = Math.cos(angle) * r
          let z = Math.sin(angle) * r
          let y = -treeHeight * 0.5 + t * treeHeight - treeYOffset

          // è£…é¥°çƒé€»è¾‘ (æ”¾åœ¨æ ‘çš„è¡¨é¢)
          if (Math.random() < 0.08) {
            const surfaceR = currentMaxR * (0.9 + Math.random() * 0.1) // è¡¨é¢é™„è¿‘
            x = Math.cos(angle) * surfaceR
            z = Math.sin(angle) * surfaceR

            p.isDecoration = true
            p.color = CONFIG.colors[Math.floor(Math.random() * 4) + 7] // å–åå‡ ä¸ªäº®è‰²
            p.baseSize = Math.random() * 2 + 1.5
          } else {
            p.isDecoration = false
            // æ ‘å¶é¢œè‰²
            const greenIndex = Math.floor(t * 6)
            p.color = CONFIG.colors[Math.min(greenIndex, 6)]
          }

          p.setTarget(x, y, z)
        })
      }

      /**
       * åˆå§‹åŒ–èƒŒæ™¯é›ªèŠ±
       */
      function initSnow() {
        snowParticles = []
        for (let i = 0; i < CONFIG.snowCount; i++) {
          snowParticles.push(new Snow(width, height))
        }
      }

      /**
       * åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
       */
      function initParticles() {
        particles = []
        for (let i = 0; i < CONFIG.particleCount; i++) {
          particles.push(new Particle(width, height))
        }
        calculateTreeShape()
        initSnow()
      }

      /**
       * æ¸²æŸ“å¾ªç¯
       */
      function loop() {
        // æ‹–å°¾æ•ˆæœ
        ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'
        ctx.fillRect(0, 0, width, height)

        // ç»˜åˆ¶èƒŒæ™¯é›ªèŠ± (ä¸å‘å…‰ï¼Œæ­£å¸¸æ··åˆ)
        ctx.globalCompositeOperation = 'source-over'
        snowParticles.forEach((p) => {
          p.update(width, height)
          p.draw(ctx)
        })

        // å¯ç”¨å‘å…‰æ··åˆæ¨¡å¼ (ä»…å¯¹æ ‘ç²’å­)
        ctx.globalCompositeOperation = 'lighter'

        const centerX = width / 2
        const centerY = height / 2

        // æ›´æ–°æ—‹è½¬è§’åº¦
        if (isAssembling) {
          treeRotation += CONFIG.rotationSpeed
        }

        particles.forEach((p) => {
          p.update(isAssembling, width, height)
          p.draw(ctx, centerX, centerY, treeRotation)
        })

        ctx.globalCompositeOperation = 'source-over'

        animationFrameId = requestAnimationFrame(loop)
      }

      /**
       * åˆ‡æ¢çŠ¶æ€é€»è¾‘
       * @param {boolean} shouldAssemble
       */
      function toggleState(shouldAssemble) {
        if (isAssembling === shouldAssemble) return // çŠ¶æ€æœªæ”¹å˜

        isAssembling = shouldAssemble

        if (isAssembling) {
          stateTextEl.innerText = 'èšåˆ'
          stateTextEl.style.color = '#00ff88'
        } else {
          stateTextEl.innerText = 'æ‰“æ•£'
          stateTextEl.style.color = '#ff4444'
          // è§¦å‘çˆ†ç‚¸æ•ˆæœ (ç›¸å¯¹äºæ ‘ä¸­å¿ƒ 0,0,0)
          particles.forEach((p) => p.explode(0, 0))
        }
      }

      // ==========================================
      // MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
      // ==========================================

      /**
       * å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
       * @param {object} results
       */
      function onResults(results) {
        if (!handModelLoaded) {
          handModelLoaded = true
          statusEl.style.opacity = 0 // éšè—åŠ è½½æç¤º
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          // å–ç¬¬ä¸€åªæ£€æµ‹åˆ°çš„æ‰‹
          const landmarks = results.multiHandLandmarks[0]

          // ç®€å•çš„å¼ æ‰‹/æ¡æ‹³æ£€æµ‹ç®—æ³•
          // è®¡ç®—æŒ‡å°– (8, 12, 16, 20) åˆ° æŒå¿ƒ (0 æˆ– 9) çš„å¹³å‡è·ç¦»
          // è¿™é‡Œä½¿ç”¨ 0 (WRIST) ä½œä¸ºå‚è€ƒç‚¹æ›´ç¨³å®š

          const wrist = landmarks[0]
          const tips = [8, 12, 16, 20] // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡å°–

          let avgDistance = 0

          tips.forEach((idx) => {
            const tip = landmarks[idx]
            // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦» (ä»…ä½¿ç”¨ x, y)
            const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2))
            avgDistance += dist
          })

          avgDistance /= tips.length

          // é˜ˆå€¼åˆ¤æ–­ (æ ¹æ®ç»éªŒå€¼è°ƒè¯•ï¼ŒWebcamåæ ‡æ˜¯å½’ä¸€åŒ–çš„ 0.0~1.0)
          // é€šå¸¸æ¡æ‹³æ—¶è·ç¦»å¾ˆå° (< 0.25)ï¼Œå¼ æ‰‹æ—¶è·ç¦»è¾ƒå¤§ (> 0.4)

          // è°ƒè¯•æ—¥å¿— (å¯é€‰æ‰“å¼€)
          // console.log("Avg Dist:", avgDistance);

          let statusText = 'æœªçŸ¥çŠ¶æ€'
          let statusColor = 'white'

          if (avgDistance < 0.25) {
            // è®¤ä¸ºæ˜¯æ¡æ‹³ -> æ ‘
            toggleState(true)
            statusText = 'âœŠ æ¡æ‹³ (èšåˆ)'
            statusColor = '#00ff88'
          } else if (avgDistance > 0.35) {
            // è®¤ä¸ºæ˜¯å¼ æ‰‹ -> æ‰“æ•£
            toggleState(false)
            statusText = 'ğŸ– å¼ å¼€ (æ‰“æ•£)'
            statusColor = '#ff4444'
          } else {
            statusText = 'âœ‹ è°ƒæ•´ä¸­...'
            statusColor = '#ffff00'
          }

          // æ›´æ–°å³ä¸‹è§’çŠ¶æ€æ–‡å­—
          gestureStatusEl.innerText = statusText
          gestureStatusEl.style.color = statusColor

          // æ›´æ–°å³ä¸‹è§’é¢„è§ˆç”»é¢
          // 1. ç»˜åˆ¶è§†é¢‘å¸§
          gestureCtx.save()
          gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height)
          gestureCtx.drawImage(results.image, 0, 0, gestureCanvas.width, gestureCanvas.height)

          // 2. ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
          if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
              drawConnectors(gestureCtx, landmarks, HAND_CONNECTIONS, {
                color: '#00FF00',
                lineWidth: 5,
              })
              drawLandmarks(gestureCtx, landmarks, {
                color: '#FF0000',
                lineWidth: 2,
              })
            }
          }
          gestureCtx.restore()
        } else {
          // æœªæ£€æµ‹åˆ°æ‰‹
          gestureStatusEl.innerText = 'æœªæ£€æµ‹åˆ°æ‰‹'
          gestureStatusEl.style.color = '#aaaaaa'

          // ä»ç„¶æ˜¾ç¤ºè§†é¢‘æµ
          gestureCtx.drawImage(results.image, 0, 0, gestureCanvas.width, gestureCanvas.height)
        }
      }

      /**
       * åˆå§‹åŒ– MediaPipe Hands
       */
      async function initHands() {
        try {
          const hands = new Hands({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            },
          })

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7,
          })

          hands.onResults(onResults)

          const camera = new Camera(videoElement, {
            onFrame: async () => {
              await hands.send({ image: videoElement })
            },
            width: 640,
            height: 480,
          })

          await camera.start()
        } catch (error) {
          console.error('æ‘„åƒå¤´æˆ–æ¨¡å‹åˆå§‹åŒ–å¤±è´¥:', error)
          statusEl.innerText = 'åˆå§‹åŒ–å¤±è´¥: è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™æˆ–ç½‘ç»œè¿æ¥'
          statusEl.style.color = 'red'
        }
      }

      // ==========================================
      // å¯åŠ¨å…¥å£
      // ==========================================

      window.addEventListener('resize', resize)

      // å¯åŠ¨
      resize()
      initParticles()
      loop()
      initHands() // å¯åŠ¨æ‘„åƒå¤´å’ŒAI
    </script>
  </body>
</html>
